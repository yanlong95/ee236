import numpy as np
import cvxpy as cp
import tensorflow as tf
mnist = tf.keras.datasets.mnist


(X_train_raw, y_train), (X_test_raw, y_test) = mnist.load_data()
X_train = X_train_raw.reshape(X_train_raw.shape[0], -1)
X_test = X_test_raw.reshape(X_test_raw.shape[0], -1)


def train(K,X_train,y_train):  
    # Iterate binary train data for all combinations
    for i in range(K):
        for j in range(K):
            if j > i:
                idxi = np.where(y_train == i)
                idxj = np.where(y_train == j)
                X_traini = X_train[idxi[0],:]
                X_trainj = X_train[idxj[0],:]
                if i == 0:
                    y_traini = y_train[idxi[0]] + 1
                else:
                    y_traini = y_train[idxi[0]] // i
                y_trainj = y_train[idxj[0]] // -j
                permutation = np.random.permutation(y_traini.shape[0]+y_trainj.shape[0])
                train_data = np.concatenate((X_traini, X_trainj), axis=0)[permutation, :]
                train_label = np.concatenate((y_traini, y_trainj))[permutation]
                print(i,j)
                W = cp.Variable((784,))
                w = cp.Variable()
                loss = cp.sum(cp.pos(1 - cp.multiply(train_label, train_data @ W - w)))
                prob = cp.Problem(cp.Minimize(loss))
                prob.solve()
    return W,w

def test(K,W,w,X_test,y_test):
    for i in range(K):
        for j in range(K):
            if j > i:
                idxi = np.where(y_test == i)
                idxj = np.where(y_test == j)
                X_testi = X_test[idxi[0],:]
                X_testj = X_test[idxj[0],:]
                if i == 0:
                    y_testi = y_test[idxi[0]] + 1
                else:
                    y_testi = y_test[idxi[0]] // i
                y_testj = y_test[idxj[0]] // -j
                permutation = np.random.permutation(y_testi.shape[0]+y_testj.shape[0])
                test_data = np.concatenate((X_testi, X_testj), axis=0)[permutation, :]
                test_label = np.concatenate((y_testi, y_testj))[permutation]
                M = test_label.shape[0]
                f = test_label * (test_data @ W.value - w.value)
                Pi = np.zeros(M)
                for m in range(M):
                    if f[m] <= 0:
                        Pi[m] = 0
                    else:
                        Pi[m] = 1
                P = sum(Pi)/M
    return P                

if __name__ == '__main__':
    W,w = train(2,X_train,y_train)
    P = test(2,W,w,X_test,y_test)
    print(w.value)
    print(P)
